from django.db import models
from django.utils.translation import ugettext_lazy as _

from jsonfield import JSONField
import swapper

__all__ = ["Protection", "AssignedProtection", "installed_protections", "add_protection"]

installed_protections = {}

def add_protection(ptype):
    def temp(func):
        if ptype in installed_protections:
            raise Exception("Duplicate protection name")
        installed_protections[ptype] = func
        return func
    return temp


class ProtectionManager(models.Manager):
    def invalid(self):
        return self.get_queryset().exclude(code__in=installed_protections)

    def valid(self):
        return self.get_queryset().filter(code__in=installed_protections)

# autogenerated, no choices required
class Protection(models.Model):
    objects = ProtectionManager()
    code = models.SlugField(max_length=10, primary_key=True)

    @classmethod
    def create_protections(cls):
        for i in installed_protections:
            cls.objects.create(code=i)

    @classmethod

    def __str__(self):
        return _(self.code)

    def validate(self, user, data, request):
        return self.protections[self.code].validate(user, data, request)

class AssignedProtection(models.Model):
    protection = models.ForeignKey("spider.Protection", on_delete=models.CASCADE, related_name="assigned", limit_choices_to={"code__in": "installed_protections"}, editable=False)
    usercomponent = models.ForeignKey(swapper.get_model_name('spider', 'UserComponent'), on_delete=models.CASCADE, editable=False)
    # data for protection
    protectiondata = JSONField(default={}, null=False)
    created = models.DateTimeField(auto_now_add=True, editable=False)
    modified = models.DateTimeField(auto_now=True, editable=False)
    active = models.BooleanField(default=True)
    class Meta:
        unique_together = [("protection", "usercomponent"),]


    def validate(self, request):
        return self.protection.validate(usercomponent.user, self.protectiondata, request)

# if specified with multiple protections all protections must be fullfilled
@add_protection("deny")
def validate_deny(user, data, request):
    return False

@add_protection("friends")
def validate_friends(user, data, request):
    if request.user.username in data.get("friends", []):
        return True
    else:
        return False
