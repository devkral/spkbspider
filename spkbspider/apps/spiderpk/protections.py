from django.db import models
from django.utils.translation import ugettext_lazy as _

from jsonfield import JSONField

__all__ = ["Protection"]

class ProtectionManager(models.Manager):
    def invalid(self):
        return self.get_queryset().exclude(code__in=self.model.protections)

    def valid(self):
        return self.get_queryset().filter(code__in=self.model.protections)

# autogenerated, no choices required
class Protection(models.Model):
    objects = ProtectionManager()
    code = models.SlugField(max_length=10, primary_key=True)
    protections = {}

    @classmethod
    def create_protections(cls):
        for i in cls.protections:
            cls.objects.create(code=i)

    @classmethod
    def add(cls, ptype):
        def temp(func):
            if ptype in cls.protections:
                raise Exception("Duplicate protection name")
            cls.protections[ptype] = func
            return func
        return temp

    def __str__(self):
        return _(self.code)

    def validate(self, user, data, request):
        return self.protections[self.code].validate(user, data, request)


class AssignedProtection(models.Model):
    protection = models.ForeignKey(Protection, on_delete=models.CASCADE, related_name="assigned", editable=False)
    usercomponent = models.ForeignKey("spiderpk.UserComponent", on_delete=models.CASCADE, editable=False)
    # data for protection
    protectiondata = JSONField(default={}, null=False)
    created = models.DateTimeField(auto_now_add=True, editable=False)
    modified = models.DateTimeField(auto_now=True, editable=False)
    active = models.BooleanField(default=True)
    class Meta:
        unique_together = [("protection", "usercomponent"),]


    def validate(self, request):
        return self.protection.validate(usercomponent.user, self.protectiondata, request)

# if specified with multiple protections all protections must be fullfilled
@Protection.add("deny")
def validate_deny(user, data, request):
    return False

@Protection.add("self")
def validate_user(user, data, request):
    if request.user.is_authenticated and request.user.pk == user.pk:
        return True
    else:
        return False

@Protection.add("friends")
def validate_friends(user, data, request):
    if request.user.pk in data.get("friends", []):
        return True
    else:
        return False
