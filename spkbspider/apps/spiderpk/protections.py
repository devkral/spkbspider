from django.db import models
from django.utils.translation import ugettext_lazy as _

__all__ = ["Protection"]

class ProtectionManager(models.Manager):
    def invalid(self):
        return self.get_queryset().exclude(code__in=self.model.protections)

    def valid(self):
        return self.get_queryset().filter(code__in=self.model.protections)

# autogenerated, no choices required
class Protection(models.Model):
    objects = ProtectionManager()
    code = models.CharField(max_length=10, primary_key=True)
    protections = {}
    def validate(self, component, request):
        return self.protections[self.code].validate(component, request)

    @classmethod
    def create_protections(cls):
        for i in cls.protections:
            cls.objects.create(code=i)

    @classmethod
    def add(cls, ptype):
        def temp(func):
            if ptype in cls.protections:
                raise Exception("Duplicate protection name")
            cls.protections[ptype] = func
            return func
        return temp

    def __str__(self):
        return _(self.code)


class AssignedProtection(models.Model):
    protection = models.ForeignKey(Protection, on_delete=models.CASCADE, related_name="assigned")
    usercomponent = models.ForeignKey("spiderpk.UserComponent", on_delete=models.CASCADE)
    # data for
    data = JSONField(default={}, null=False)
    created = models.DateTimeField(auto_now_add=True)
    modified = models.DateTimeField(auto_now=True)
    class Meta:
        unique_together = [("protection", "usercomponent"),]

@Protection.add("self")
def validate_user(component, request):
    if request.user.is_authenticated and request.user.pk == component.user.pk:
        return True
    else:
        return False

@Protection.add("friends")
def validate_friends(component, request):
    if request.user.pk in component.authdata.get("friends", []) == user.pk:
        return True
    else:
        return False
